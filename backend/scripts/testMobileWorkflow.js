import { db } from '../config/firebase.js';

/**
 * Script de test pour valider le workflow mobile
 * Compatible avec l'app Flutter
 */

const TEST_USER_UID = 'test-mobile-user-' + Date.now();

// Test 1: Obtenir les types de plaintes
async function testGetComplaintTypes() {
  console.log('\nüß™ Test 1: R√©cup√©ration des types de plaintes');
  
  try {
    // Simuler la requ√™te mobile
    const types = {
      complaintTypes: [
        'Retard de paiement',
        'Prestation insatisfaisante',
        'Probl√®me administratif',
        'Autre'
      ],
      targetTypes: [
        'Structure publique',
        'Structure priv√©e',
        'Particulier'
      ],
      submissionTypes: [
        'Vocal',
        'Expos√©',
        'Suite expos√©'
      ]
    };
    
    console.log('‚úÖ Types r√©cup√©r√©s:', types);
    return types;
  } catch (error) {
    console.error('‚ùå Erreur:', error);
    return null;
  }
}

// Test 2: R√©cup√©rer la hi√©rarchie administrative
async function testAdministrativeHierarchy() {
  console.log('\nüß™ Test 2: Hi√©rarchie administrative');
  
  try {
    // R√©cup√©rer les minist√®res
    const ministeresSnapshot = await db.collection('minist√®res').where('actif', '==', true).get();
    console.log(`üìã ${ministeresSnapshot.size} minist√®res trouv√©s`);
    
    if (ministeresSnapshot.empty) {
      console.log('‚ö†Ô∏è  Aucun minist√®re trouv√©. Ex√©cutez "npm run seed:mobile" d\'abord');
      return false;
    }
    
    // Tester avec le premier minist√®re
    const ministere = ministeresSnapshot.docs[0];
    const ministereData = ministere.data();
    console.log(`üìã Test avec: ${ministereData.nom}`);
    
    // R√©cup√©rer les directions
    const directionsSnapshot = await db.collection('directions')
      .where('ministereId', '==', ministere.id)
      .where('actif', '==', true)
      .get();
    
    console.log(`üìÅ ${directionsSnapshot.size} directions trouv√©es`);
    
    if (!directionsSnapshot.empty) {
      const direction = directionsSnapshot.docs[0];
      const directionData = direction.data();
      console.log(`üìÅ Test avec: ${directionData.nom}`);
      
      // R√©cup√©rer les services
      const servicesSnapshot = await db.collection('services')
        .where('directionId', '==', direction.id)
        .where('actif', '==', true)
        .get();
      
      console.log(`üè¢ ${servicesSnapshot.size} services trouv√©s`);
      
      if (!servicesSnapshot.empty) {
        const service = servicesSnapshot.docs[0];
        const serviceData = service.data();
        console.log(`üè¢ Test avec: ${serviceData.nom}`);
        
        return {
          ministere: { id: ministere.id, ...ministereData },
          direction: { id: direction.id, ...directionData },
          service: { id: service.id, ...serviceData }
        };
      }
    }
    
    return { ministere: { id: ministere.id, ...ministereData } };
    
  } catch (error) {
    console.error('‚ùå Erreur:', error);
    return null;
  }
}

// Test 3: Cr√©er une plainte de test (workflow mobile complet)
async function testCreateComplaint(hierarchy) {
  console.log('\nüß™ Test 3: Cr√©ation de plainte (workflow mobile)');
  
  if (!hierarchy) {
    console.log('‚ö†Ô∏è  Pas de hi√©rarchie disponible, test ignor√©');
    return false;
  }
  
  try {
    const complaintData = {
      title: 'Test Mobile - Retard de paiement',
      description: 'Plainte de test cr√©√©e via le workflow mobile. Cette plainte simule une soumission depuis l\'application Flutter avec tous les champs requis.',
      complaintType: 'Retard de paiement',
      targetType: 'Structure publique',
      submissionTypes: ['Expos√©', 'Vocal'],
      
      // Structure publique (hi√©rarchie)
      publicStructure: {
        ministereId: hierarchy.ministere.id,
        ministereName: hierarchy.ministere.nom,
        directionId: hierarchy.direction?.id || '',
        directionName: hierarchy.direction?.nom || '',
        serviceId: hierarchy.service?.id || '',
        serviceName: hierarchy.service?.nom || ''
      },
      
      // Localisation GPS (obligatoire sur mobile)
      location: {
        latitude: 14.6937,
        longitude: -17.4441,
        address: 'Dakar, Plateau, S√©n√©gal'
      },
      
      // Simulation de m√©dias
      mediaFiles: [
        {
          type: 'image',
          url: 'https://example.com/photo1.jpg',
          filename: 'evidence_photo_1.jpg',
          size: 1024000,
          mimeType: 'image/jpeg'
        },
        {
          type: 'image',
          url: 'https://example.com/photo2.jpg',
          filename: 'evidence_photo_2.jpg',
          size: 892000,
          mimeType: 'image/jpeg'
        }
      ],
      
      // Enregistrement vocal (si type vocal s√©lectionn√©)
      vocalRecording: {
        url: 'https://example.com/recording.m4a',
        duration: 45, // en secondes
        filename: 'vocal_complaint.m4a',
        size: 2048000,
        mimeType: 'audio/mp4'
      },
      
      // M√©tadonn√©es
      status: 'en-attente',
      priority: 'moyenne',
      isDraft: false,
      submittedBy: TEST_USER_UID,
      submittedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      
      // Validation workflow mobile
      mobileWorkflow: {
        completed: true,
        steps: ['typologie', 'structure', 'expose', 'localisation', 'medias'],
        version: '1.0.0'
      },
      
      // Contexte
      context: {
        source: 'mobile_app',
        platform: 'flutter',
        version: '1.0.0',
        language: 'fr'
      }
    };
    
    // Cr√©er la plainte
    const complaintRef = await db.collection('complaints').add(complaintData);
    console.log(`‚úÖ Plainte cr√©√©e avec ID: ${complaintRef.id}`);
    
    // V√©rifier la cr√©ation
    const createdComplaint = await complaintRef.get();
    if (createdComplaint.exists) {
      const data = createdComplaint.data();
      console.log(`üìã Titre: ${data.title}`);
      console.log(`üéØ Type: ${data.complaintType} ‚Üí ${data.targetType}`);
      console.log(`üèõÔ∏è  Structure: ${data.publicStructure.ministereName}`);
      if (data.publicStructure.directionName) {
        console.log(`üìÅ Direction: ${data.publicStructure.directionName}`);
      }
      if (data.publicStructure.serviceName) {
        console.log(`üè¢ Service: ${data.publicStructure.serviceName}`);
      }
      console.log(`üìç Localisation: ${data.location.address}`);
      console.log(`üì∏ M√©dias: ${data.mediaFiles.length} images`);
      console.log(`üé§ Audio: ${data.vocalRecording ? 'Oui (' + data.vocalRecording.duration + 's)' : 'Non'}`);
      
      return complaintRef.id;
    }
    
    return null;
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation:', error);
    return null;
  }
}

// Test 4: Cr√©er un brouillon et le finaliser
async function testDraftWorkflow(hierarchy) {
  console.log('\nüß™ Test 4: Workflow brouillon ‚Üí finalisation');
  
  if (!hierarchy) {
    console.log('‚ö†Ô∏è  Pas de hi√©rarchie disponible, test ignor√©');
    return false;
  }
  
  try {
    // Cr√©er un brouillon (donn√©es minimales)
    const draftData = {
      title: 'Brouillon Mobile - Probl√®me administratif',
      description: 'Brouillon sauvegard√© depuis l\'app mobile. Description partielle...',
      complaintType: 'Probl√®me administratif',
      targetType: 'Structure publique',
      submissionTypes: ['Expos√©'],
      
      // Structure publique (partiellement remplie)
      publicStructure: {
        ministereId: hierarchy.ministere.id,
        ministereName: hierarchy.ministere.nom,
        directionId: '',
        directionName: '',
        serviceId: '',
        serviceName: ''
      },
      
      // M√©tadonn√©es brouillon
      status: 'brouillon',
      priority: 'moyenne',
      isDraft: true,
      submittedBy: TEST_USER_UID,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      
      // Workflow mobile incomplet
      mobileWorkflow: {
        completed: false,
        steps: ['typologie', 'structure'], // Seules 2 √©tapes compl√©t√©es
        version: '1.0.0'
      },
      
      context: {
        source: 'mobile_app',
        platform: 'flutter',
        version: '1.0.0',
        language: 'fr'
      }
    };
    
    // Cr√©er le brouillon
    const draftRef = await db.collection('complaints').add(draftData);
    console.log(`üìù Brouillon cr√©√© avec ID: ${draftRef.id}`);
    
    // Attendre un peu pour simuler l'utilisateur qui continue
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Finaliser le brouillon (compl√©ter les donn√©es)
    const finalizedData = {
      description: draftData.description + '\n\nCompl√©ment ajout√© apr√®s sauvegarde. Le probl√®me concerne les d√©lais de traitement des dossiers qui sont bien trop longs.',
      
      publicStructure: {
        ...draftData.publicStructure,
        directionId: hierarchy.direction?.id || '',
        directionName: hierarchy.direction?.nom || '',
        serviceId: hierarchy.service?.id || '',
        serviceName: hierarchy.service?.nom || ''
      },
      
      // Ajouter localisation
      location: {
        latitude: 14.7158,
        longitude: -17.4731,
        address: 'Dakar, M√©dina, S√©n√©gal'
      },
      
      // Ajouter un m√©dia
      mediaFiles: [
        {
          type: 'image',
          url: 'https://example.com/document.jpg',
          filename: 'document_administratif.jpg',
          size: 1500000,
          mimeType: 'image/jpeg'
        }
      ],
      
      // Finalisation
      status: 'en-attente',
      isDraft: false,
      submittedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      
      // Workflow complet
      mobileWorkflow: {
        completed: true,
        steps: ['typologie', 'structure', 'expose', 'localisation', 'medias'],
        version: '1.0.0'
      }
    };
    
    // Mettre √† jour le brouillon
    await draftRef.update(finalizedData);
    console.log(`‚úÖ Brouillon finalis√© avec succ√®s`);
    
    // V√©rifier la finalisation
    const finalizedDoc = await draftRef.get();
    if (finalizedDoc.exists) {
      const data = finalizedDoc.data();
      console.log(`üìã Statut: ${data.status} (√©tait brouillon)`);
      console.log(`‚úÖ Workflow: ${data.mobileWorkflow.completed ? 'Complet' : 'Incomplet'}`);
      console.log(`üìç Localisation ajout√©e: ${data.location ? 'Oui' : 'Non'}`);
      console.log(`üì∏ M√©dias ajout√©s: ${data.mediaFiles?.length || 0}`);
    }
    
    return draftRef.id;
    
  } catch (error) {
    console.error('‚ùå Erreur dans le workflow brouillon:', error);
    return null;
  }
}

// Test 5: Tester les requ√™tes avec filtres (comme sur mobile)
async function testMobileQueries() {
  console.log('\nüß™ Test 5: Requ√™tes mobiles avec filtres');
  
  try {
    // Requ√™te 1: Toutes les plaintes de l'utilisateur
    const userComplaintsSnapshot = await db.collection('complaints')
      .where('submittedBy', '==', TEST_USER_UID)
      .orderBy('createdAt', 'desc')
      .get();
    
    console.log(`üë§ Plaintes de l'utilisateur test: ${userComplaintsSnapshot.size}`);
    
    // Requ√™te 2: Plaintes par type
    const paymentComplaintsSnapshot = await db.collection('complaints')
      .where('complaintType', '==', 'Retard de paiement')
      .where('submittedBy', '==', TEST_USER_UID)
      .get();
    
    console.log(`üí∞ Plaintes 'Retard de paiement': ${paymentComplaintsSnapshot.size}`);
    
    // Requ√™te 3: Brouillons uniquement
    const draftsSnapshot = await db.collection('complaints')
      .where('isDraft', '==', true)
      .where('submittedBy', '==', TEST_USER_UID)
      .get();
    
    console.log(`üìù Brouillons: ${draftsSnapshot.size}`);
    
    // Requ√™te 4: Plaintes finalis√©es uniquement
    const finalizedSnapshot = await db.collection('complaints')
      .where('isDraft', '==', false)
      .where('submittedBy', '==', TEST_USER_UID)
      .get();
    
    console.log(`‚úÖ Plaintes finalis√©es: ${finalizedSnapshot.size}`);
    
    // Afficher d√©tails de chaque plainte
    if (!userComplaintsSnapshot.empty) {
      console.log('\nüìã D√©tails des plaintes cr√©√©es:');
      userComplaintsSnapshot.docs.forEach((doc, index) => {
        const data = doc.data();
        console.log(`  ${index + 1}. ${data.title} (${data.status}) - ${data.isDraft ? 'BROUILLON' : 'FINALIS√â'}`);
      });
    }
    
    return true;
    
  } catch (error) {
    console.error('‚ùå Erreur lors des requ√™tes:', error);
    return false;
  }
}

// Fonction de nettoyage
async function cleanup() {
  console.log('\nüßπ Nettoyage des donn√©es de test...');
  
  try {
    const testComplaintsSnapshot = await db.collection('complaints')
      .where('submittedBy', '==', TEST_USER_UID)
      .get();
    
    if (!testComplaintsSnapshot.empty) {
      const batch = db.batch();
      testComplaintsSnapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
      });
      
      await batch.commit();
      console.log(`‚úÖ ${testComplaintsSnapshot.size} plaintes de test supprim√©es`);
    } else {
      console.log('‚ÑπÔ∏è  Aucune plainte de test √† supprimer');
    }
    
  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Script principal
async function runMobileWorkflowTests() {
  console.log('üöÄ D√©marrage des tests du workflow mobile');
  console.log('=' .repeat(50));
  
  try {
    // Test 1: Types de plaintes
    const types = await testGetComplaintTypes();
    if (!types) return;
    
    // Test 2: Hi√©rarchie administrative
    const hierarchy = await testAdministrativeHierarchy();
    if (!hierarchy) {
      console.log('\n‚ö†Ô∏è  Tests n√©cessitant la hi√©rarchie administrative ignor√©s');
      console.log('üí° Ex√©cutez "npm run seed:mobile" pour cr√©er les donn√©es de test');
      return;
    }
    
    // Test 3: Cr√©ation de plainte compl√®te
    const complaintId = await testCreateComplaint(hierarchy);
    if (!complaintId) return;
    
    // Test 4: Workflow brouillon
    const draftId = await testDraftWorkflow(hierarchy);
    
    // Test 5: Requ√™tes mobiles
    const queriesOk = await testMobileQueries();
    
    // R√©sum√©
    console.log('\n' + '='.repeat(50));
    console.log('üìä R√âSUM√â DES TESTS');
    console.log('='.repeat(50));
    console.log(`‚úÖ Types de plaintes: ${types ? 'OK' : '√âCHEC'}`);
    console.log(`‚úÖ Hi√©rarchie administrative: ${hierarchy ? 'OK' : '√âCHEC'}`);
    console.log(`‚úÖ Cr√©ation de plainte: ${complaintId ? 'OK' : '√âCHEC'}`);
    console.log(`‚úÖ Workflow brouillon: ${draftId ? 'OK' : '√âCHEC'}`);
    console.log(`‚úÖ Requ√™tes mobiles: ${queriesOk ? 'OK' : '√âCHEC'}`);
    
    console.log('\nüéâ Tests du workflow mobile termin√©s avec succ√®s !');
    console.log('üì± Le backend est pr√™t pour l\'int√©gration avec l\'app Flutter');
    
  } catch (error) {
    console.error('üí• Erreur g√©n√©rale:', error);
  }
}

// Script principal
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--cleanup')) {
    await cleanup();
    process.exit(0);
  }
  
  await runMobileWorkflowTests();
  
  // Nettoyage automatique si demand√©
  if (args.includes('--auto-cleanup')) {
    await cleanup();
  }
  
  process.exit(0);
}

// Ex√©cuter le script si appel√© directement
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}

export { runMobileWorkflowTests, cleanup }; 